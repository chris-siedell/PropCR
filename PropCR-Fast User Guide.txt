======================================
"PropCR-Fast User Guide.txt"
22 May 2017 - Chris Siedell
http://siedell.com/projects/PropCR/
======================================


This is a guide for using the "PropCR-Fast.spin" code (and it's "-BD" variant) to make serial protocols.

PropCR-Fast exists to simplify making command-response protocols for communications between a Propeller and a PC. It takes care of the low level work of a serial transport protocol (packetization, error detection, etc.).

PropCR is based on the Crow serial protocol (v1). It may be a good idea to read the "Summary" section of "Crow Specification v1.txt" to get a sense of what PropCR is suitable for.

This particular implementation is optimized for speed. An alternate version (PropCR-Fast-BD) supports break detection, whose function is user defined.

Speeds supported:   3 Mbps @ 80 MHz
                    153.6 kbps @ 4 MHz
                    1200 bps @ 32.768 kHz

PropCR-Fast requires a stable clock source, such as a crystal or RTC.

PropCR-Fast is written in PASM and is cog-contained after initialization. It receives and sends payloads from cog-based buffers.

todo: could use more details of the PC side of things


Commands
========

A command is issued by the PC (aka host) and has the following parameters:

    - address: 0-31 (0 is broadcast)
    - muted responses: yes/no
    - type: admin/user
    - protocol: 0x0000 - 0xffff
    - payload: <binary blob of length 0 - 2047>

In PropCR the device's address is set at initialization. If a command's address does not match the device's -- and it isn't the broadcast address 0 -- then the command is silently ignored.

PropCR takes care of admin commands.

The command's protocol number must match the protocol number set by the constant conUserProtocol. If the protocol numbers don't match the command is silently ignored. The protocol number is like a port number in networking.

If a user command is received and everything is correct -- the address, protocol number, and payload (no errors detected) -- then PropCR invokes user code to process the command and send responses.


User Code
=========

After a valid user command is received and parsed PropCR will jmp to UserCode. The following registers provide user code with information about the received command:

                packetInfo      - contains the mute flag and address
                                  use conMuteFlag and conAddressMask to access
                                  user code must not modify this register
                payloadLength   - the length of the received payload, in bytes
                                  it is also used to set the length of the response payload
                Payload         - the base register of the payload buffer (register 0, see below)

Examples of using the packetInfo register:

                test        packetInfo, #conMuteFlag         wc      'c=1 responses are muted
                test        packetInfo, #conAddressMask      wz      'z=1 broadcast command

Recall: the host can elect for responses to be muted, in which case a device must not send a response. The host can also send commands to individually addressed devices, or to all devices (broadcast commands, which are always muted).

These are the options to return to PropCR code:

                call        #SendIntermediate       'sends an intermediate response and returns
                jmp         #SendFinalResponse      'sends the final response and then listens for
                                                    ' the next command
                call        #SendFinalAndReturn     'returns to user code after sending the
                                                    ' final response
                jmp         #RecoveryMode           'waits for line idle or break and then listens
                                                    ' for the next command
                jmp         #ReceiveCommand         'immediately begins listening for a command

To send a response first prepare the sending payload buffer. (By default this is the same as the receiving buffer, but that can be changed using sendBufferPointer -- see "The Payload Buffer".) Set payloadLength appropriately, and then call or jmp to one of the Send* routines above.

There are two types of responses: intermediate and final. There can by any number of intermediate responses, but there must be just one final response. Failure to send an expected response will manifest as a timeout error for the host.

The PropCR layer does not provide error responses -- error responses will have to be defined within the user's protocol.

The option to return to user code after sending the final response exists for situations where the work is to be performed after acknowledgement (e.g. restarting). To go back to PropCR code after sending the final response jmp to ReceiveCommand.

The Send* routines will return without sending if the host has elected to mute responses.


An Example
==========

In the following example the device echos the received payload back to the host in multiple intermediate responses, shortening the payload by one byte after each response. Then it sends an empty final response, finishing the transaction.

UserCode
                cmp         payloadLength, #0       wz      'z=1 nothing to echo or shorten
        if_z    jmp         #SendFinalResponse

:loop           call        #SendIntermediate               'echo the payload
                                                            ' (assumes sendBufferPointer = Payload)
                djnz        payloadLength, #:loop           'shorten the payload

                jmp         #SendFinalResponse              'goes to ReceiveCommand after sending


The Payload Buffer
==================

Command payloads are always received into the payload buffer (Payload). This buffer starts at register 0 (see "Cog Layout").

By default response payloads are also sent from the payload buffer. This can be changed by setting sendBufferPointer to another address.

User code can assume that sendBufferPointer is not changed by PropCR. When PropCR has to change the value (for responding to admin commands) it will always restore the original value when finished.

The size of the payload buffer is set by the conNumPayloadRegisters constant. The size must always be an even number of registers (transmitting will fail if it isn't even).

Command payloads must fit in the buffer or the command will be silently ignored. The Crow specification allows sending payloads up to 2047 bytes. The cog-based buffer will always be smaller than this limit so the PC must not send oversized command payloads. The PC can obtain the device's maximum payload length by using the getDeviceInfo admin command.

The payload buffer also holds the initialization code. The size of this code sets a lower limit on the size of the buffer.


Byte Ordering
=============

The PC's host code and the PropCR-Fast code cooperate so that byte ordering is sensible for the propeller. Suppose a command is issued at the host with the following call:

        connection.sendUserCommand(address, protocol, payload);
        
where payload is a ten byte vector with values {P0, P1, P2, ..., P9}. Then user code on the propeller will see those bytes in the payload buffer as 

        Register            | byte3 | byte2 | byte1 | byte0 |
        --------------------|-------|-------|-------|-------|
        Payload             |   P3  |   P2  |   P1  |   P0  |
        +1                  |   P7  |   P6  |   P5  |   P4  |
        +2                  |   *   |   *   |   P9  |   P8  |     * = undefined
        +3                  |   *   |   *   |   *   |   *   |

Likewise, if user code sends a response with those same bytes the host will receive a payload
in the expected order: P0, P1, P2, ..., P9.

Important: if the payload length is not a multiple of four then the non-payload upper bytes of the last register will be undefined. Additionally, the remaining registers in the payload buffer will be undefined.

(If you use a logic analyzer you will see that bytes are reordered in transmission when sending to the propeller, but are not when sending to the PC. This strategy was chosen to decrease the number of instructions required on the propeller.)


Break Detection
===============

PropCR-Fast-BD features break detection. When it detects a break condition it will jmp to BreakHandler. When the break handling code is finished it should verify that the break condition is over (or wait until it is) and then jmp to ReceiveCommand.


Cog Layout
==========

PropCR-Fast has the following cog layout:

        +-----------------------+ - 0
        |                       |
        |     Payload Buffer    |         PropCR-Fast v0.1 initialization code takes xx registers.
        |   and Initialization  |
        |                       |
        |-----------------------| - N = conNumPayloadRegisters*
        |                       |
        |         PropCR        |         PropCR-Fast v0.1 code takes xx registers
        |         Block         |           -- xx for break detection.
        |                       |
        |-----------------------| - N + xx (xx for break detection)
        |                       |
        |         User          |         This block contains user code, settings, buffers, etc.
        |         Block         |
        |                       |
        |-----------------------| - 486
        |      Temporaries      |         Temporaries take 10 registers: 486 - 495.
        +-----------------------+ - 496

*conNumPayloadRegisters must be even, and sufficiently large for the initialization code.

This layout was chosen to simplify executing received code in the payload buffer -- this is a way of expanding the code space without involving the hub. Received code can be compiled to always run in the same locations and it can take advantage of temporary (scratch) registers at fixed locations.

The payload buffer is not statically allocated -- the initialization code shifts the PropCR and user blocks up into place to avoid wasting excessive hub ram.

There are ten fixed temporary (scratch) registers at the end of the usable cog space. User code may also use these registers (see the "Temporaries" section for specifics).

Future guarantee: if the PropCR-Fast code is revised it will maintain this layout, including the ten temporary registers (if more temporaries are required by PropCR they will be placed within its block).


Temporaries
===========

PropCR-Fast allocates ten temporary registers which user code can also use. These are located at registers 486 to 495. Naturally, these registers are undefined when user code is jmp'd to (this includes the break handler). Some of these temporaries are used by the sending code, and some are not. Specifically,

    Registers 486 - 490 (tmp0 - tmp4) preserve their values during a Send* call.
    Registers 491 - 495 (tmp5v - tmp9v) are undefined after a Send* call.

Note that the temporaries that change during a Send* call have a "v" (volatile) in their names.

This layout of temporaries (and their volatility) will be maintained in any future revisions of PropCR-Fast.


Special Purpose Registers, Pins, and Counters
=============================================

PropCR-Fast uses ctrb during recovery mode (and turns it off before exiting recovery mode). It sets frqb to 1 during initialization and assumes it never changes. Additionally, it assumes ctrb is off when the receiving code is running (it uses phsb as a scratch register).

PropCR-Fast does not use ctra.

PropCR-Fast uses the ina, inb, cnt, par, and phsb shadow registers. User code should assume that these are undefined when called, and that they are undefined after a Send* call returns.

PropCR-Fast makes the tx pin an output only when sending.


The Interbyte Timeout
======================

The interbyte timeout is used by the PropCR parser to decide when a new packet has arrived. It is the maximum amount of time (in system clocks) that PropCR will allow between bytes of a packet.

PropCR attempts to parse the packet as it arrives (instead of receiving the packet into a buffer and then parsing it). When a new byte is received PropCR calculates how much time has elapsed since the last byte was received. If this time exceeds the interbyte timeout then PropCR assumes this new byte is the first byte of a packet and it resets the parser.

The interbyte timeout should be short so that PropCR can reliably detect the start of a new packet (its parser can not work retrospectively). However, the timeout must be greater than the stop bit(s) period (measured in clocks), plus some safety margin.

By default PropCR uses 16 bit periods as the timeout. This works if the PC sends a steady stream of bytes, with no pauses in between. Alternatively, commented-out code in the setParams method shows how to assign a timeout given in milliseconds.


A Problem, and a Solution
=========================

The problem: PropCR uses the cnt clock to determine when an interbyte timeout has occurred, which means PropCR will fail to correctly parse a new packet if the following statements are true:
    - it has been more than 2^32 clocks since the last received byte (53 seconds at 80 MHz),
    - the parser was stuck trying to parse a non-initial byte, and
    - if by chance the new packet arrives such that the rolled-over cnt indicates that a timeout has not occurred (this has a probability of timeout/2^32, assuming a uniformly random cnt).

What will happen in this situation is that PropCR will consider the new packet to be a continuation of the previous partial "packet" is was parsing (which may have just been random data). Very likely this parsing will fail due to formatting and error detection problems, PropCR will enter recovery mode, and the PC will see the transaction timeout. The next transaction should be OK if it is begun after the interbyte timeout has elapsed, but before 2^32 clocks. (The case where the new packet somehow validly completes the previous partial "packet" is even more unlikely, but not impossible. It shows why it's not a bad idea to include further validity checks within the payload.)

The solution: If it has been more than 2^32 clocks since the last known communication with the propeller, ping it first. If it responds to the ping then everything is OK. If it doesn't then send a second ping (after PropCR's timeout has elapsed). This second ping should work -- if it doesn't then something else is wrong.


Recovery Mode
=============

When PropCR encounters framing errors or parsing errors it enters recovery mode. In recovery mode PropCR periodically monitors the rx line. If the rx line was idle for an interval (recoveryTime clocks) then it exits recovery mode and listens for a new command. The rationale for this is that a command will probably be preceded by a short idle period.

Since PropCR can't receive a command in recovery mode recoveryTime should be short. However, it should be more than a byte period so that PropCR can correctly detect a start bit. By default PropCR uses 16 bit periods for recoveryTime.

Recovery mode is also where PropCR-Fast-BD listens for the break condition, which it detects if the rx line was always low for at least breakMultiple*recoveryTime clocks.


Other Suggestions
=================

It's not a bad idea to include additional validity checks within the payload, such as a magic value. This way you won't depend entirely on the protocol number to filter out commands.

Protocol number 0 is a special value that reduces the command's packet header size from 8 to 6 bytes. This value is appropriate for situations where there is only one protocol being used.

The PropCR block contains the constant kFFFF (a lower word mask) which user code may find useful. It also has the constant k7FF.

If cog space is very tight:
    - PropCR has some registers which could also serve as nops (search for "potential nop").
    - If using break detection, the BreakHandler code can be placed immediately after the RecoveryMode code and the jmp eliminated.
    - Support for the getDeviceInfo command can be eliminated to recover 12 registers. Additionally eliminating ping support would recover another 6 registers.
    - If there is only one device and the tx and rx pins are separate then the tx pin can be made an output at initialization and the txRetainLine and txReleaseLine instructions eliminated.

